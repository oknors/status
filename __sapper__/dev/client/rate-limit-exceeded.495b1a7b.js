import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, c as config, v as validate_slots, o as onMount, Q as goto, m as space, e as element, t as text, z as empty, N as query_selector_all, g as detach_dev, p as claim_space, a as claim_element, b as children, f as claim_text, j as add_location, h as attr_dev, k as insert_hydration_dev, l as append_hydration_dev, n as noop, R as set_input_value, F as listen_dev, T as prevent_default, G as run_all } from './client.69e7c0f4.js';

/* src/routes/rate-limit-exceeded.svelte generated by Svelte v3.43.2 */
const file = "src/routes/rate-limit-exceeded.svelte";

// (80:0) {:else}
function create_else_block(ctx) {
	let form;
	let label;
	let span;
	let t0_value = config.i18n.rateLimitExceededGitHubPAT + "";
	let t0;
	let t1;
	let input;
	let t2;
	let button;
	let t3_value = config.i18n.rateLimitExceededSaveToken + "";
	let t3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			form = element("form");
			label = element("label");
			span = element("span");
			t0 = text(t0_value);
			t1 = space();
			input = element("input");
			t2 = space();
			button = element("button");
			t3 = text(t3_value);
			this.h();
		},
		l: function claim(nodes) {
			form = claim_element(nodes, "FORM", {});
			var form_nodes = children(form);
			label = claim_element(form_nodes, "LABEL", { class: true });
			var label_nodes = children(label);
			span = claim_element(label_nodes, "SPAN", { class: true });
			var span_nodes = children(span);
			t0 = claim_text(span_nodes, t0_value);
			span_nodes.forEach(detach_dev);
			t1 = claim_space(label_nodes);

			input = claim_element(label_nodes, "INPUT", {
				type: true,
				placeholder: true,
				class: true
			});

			label_nodes.forEach(detach_dev);
			t2 = claim_space(form_nodes);
			button = claim_element(form_nodes, "BUTTON", { type: true, class: true });
			var button_nodes = children(button);
			t3 = claim_text(button_nodes, t3_value);
			button_nodes.forEach(detach_dev);
			form_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			attr_dev(span, "class", "svelte-1e31mgz");
			add_location(span, file, 82, 6, 2032);
			attr_dev(input, "type", "text");
			attr_dev(input, "placeholder", config.i18n.rateLimitExceededCopyPastePAT);
			attr_dev(input, "class", "svelte-1e31mgz");
			add_location(input, file, 83, 6, 2092);
			attr_dev(label, "class", "svelte-1e31mgz");
			add_location(label, file, 81, 4, 2018);
			attr_dev(button, "type", "submit");
			attr_dev(button, "class", "svelte-1e31mgz");
			add_location(button, file, 88, 4, 2230);
			add_location(form, file, 80, 2, 1975);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, form, anchor);
			append_hydration_dev(form, label);
			append_hydration_dev(label, span);
			append_hydration_dev(span, t0);
			append_hydration_dev(label, t1);
			append_hydration_dev(label, input);
			set_input_value(input, /*token*/ ctx[0]);
			append_hydration_dev(form, t2);
			append_hydration_dev(form, button);
			append_hydration_dev(button, t3);

			if (!mounted) {
				dispose = [
					listen_dev(input, "input", /*input_input_handler*/ ctx[4]),
					listen_dev(form, "submit", prevent_default(/*save*/ ctx[2]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, dirty) {
			if (dirty & /*token*/ 1 && input.value !== /*token*/ ctx[0]) {
				set_input_value(input, /*token*/ ctx[0]);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(form);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(80:0) {:else}",
		ctx
	});

	return block;
}

// (77:0) {#if localStorageToken}
function create_if_block(ctx) {
	let p;
	let t0_value = config.i18n.rateLimitExceededHasSet + "";
	let t0;
	let t1;
	let button;
	let t2_value = config.i18n.rateLimitExceededRemoveToken + "";
	let t2;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			p = element("p");
			t0 = text(t0_value);
			t1 = space();
			button = element("button");
			t2 = text(t2_value);
			this.h();
		},
		l: function claim(nodes) {
			p = claim_element(nodes, "P", {});
			var p_nodes = children(p);
			t0 = claim_text(p_nodes, t0_value);
			p_nodes.forEach(detach_dev);
			t1 = claim_space(nodes);
			button = claim_element(nodes, "BUTTON", { class: true });
			var button_nodes = children(button);
			t2 = claim_text(button_nodes, t2_value);
			button_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(p, file, 77, 2, 1840);
			attr_dev(button, "class", "svelte-1e31mgz");
			add_location(button, file, 78, 2, 1887);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t0);
			insert_hydration_dev(target, t1, anchor);
			insert_hydration_dev(target, button, anchor);
			append_hydration_dev(button, t2);

			if (!mounted) {
				dispose = listen_dev(button, "click", /*remove*/ ctx[3], false, false, false);
				mounted = true;
			}
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t1);
			if (detaching) detach_dev(button);
			mounted = false;
			dispose();
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(77:0) {#if localStorageToken}",
		ctx
	});

	return block;
}

function create_fragment(ctx) {
	let title_value;
	let t0;
	let h1;
	let t1_value = config.i18n.rateLimitExceededTitle + "";
	let t1;
	let t2;
	let p0;
	let t3_value = config.i18n.rateLimitExceededIntro + "";
	let t3;
	let t4;
	let h20;
	let t5_value = config.i18n.rateLimitExceededWhatDoesErrorMean + "";
	let t5;
	let t6;
	let p1;
	let t7_value = config.i18n.rateLimitExceededErrorMeaning + "";
	let t7;
	let t8;
	let h21;
	let t9_value = config.i18n.rateLimitExceededErrorHowCanFix + "";
	let t9;
	let t10;
	let p2;
	let t11_value = config.i18n.rateLimitExceededErrorFix + "";
	let t11;
	let t12;
	let a;
	let t13_value = config.i18n.rateLimitExceededGeneratePAT + "";
	let t13;
	let t14;
	let if_block_anchor;
	document.title = title_value = config.i18n.rateLimitExceededTitle;

	function select_block_type(ctx, dirty) {
		if (/*localStorageToken*/ ctx[1]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			t0 = space();
			h1 = element("h1");
			t1 = text(t1_value);
			t2 = space();
			p0 = element("p");
			t3 = text(t3_value);
			t4 = space();
			h20 = element("h2");
			t5 = text(t5_value);
			t6 = space();
			p1 = element("p");
			t7 = text(t7_value);
			t8 = space();
			h21 = element("h2");
			t9 = text(t9_value);
			t10 = space();
			p2 = element("p");
			t11 = text(t11_value);
			t12 = space();
			a = element("a");
			t13 = text(t13_value);
			t14 = space();
			if_block.c();
			if_block_anchor = empty();
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-1xny0el\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", {});
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, t1_value);
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			p0 = claim_element(nodes, "P", { class: true });
			var p0_nodes = children(p0);
			t3 = claim_text(p0_nodes, t3_value);
			p0_nodes.forEach(detach_dev);
			t4 = claim_space(nodes);
			h20 = claim_element(nodes, "H2", {});
			var h20_nodes = children(h20);
			t5 = claim_text(h20_nodes, t5_value);
			h20_nodes.forEach(detach_dev);
			t6 = claim_space(nodes);
			p1 = claim_element(nodes, "P", {});
			var p1_nodes = children(p1);
			t7 = claim_text(p1_nodes, t7_value);
			p1_nodes.forEach(detach_dev);
			t8 = claim_space(nodes);
			h21 = claim_element(nodes, "H2", {});
			var h21_nodes = children(h21);
			t9 = claim_text(h21_nodes, t9_value);
			h21_nodes.forEach(detach_dev);
			t10 = claim_space(nodes);
			p2 = claim_element(nodes, "P", {});
			var p2_nodes = children(p2);
			t11 = claim_text(p2_nodes, t11_value);
			t12 = claim_space(p2_nodes);
			a = claim_element(p2_nodes, "A", { href: true, target: true });
			var a_nodes = children(a);
			t13 = claim_text(a_nodes, t13_value);
			a_nodes.forEach(detach_dev);
			p2_nodes.forEach(detach_dev);
			t14 = claim_space(nodes);
			if_block.l(nodes);
			if_block_anchor = empty();
			this.h();
		},
		h: function hydrate() {
			add_location(h1, file, 59, 0, 1294);
			attr_dev(p0, "class", "lead svelte-1e31mgz");
			add_location(p0, file, 61, 0, 1341);
			add_location(h20, file, 63, 0, 1399);
			add_location(p1, file, 65, 0, 1458);
			add_location(h21, file, 67, 0, 1510);
			attr_dev(a, "href", "https://docs.github.com/en/free-pro-team@latest/github/authenticating-to-github/creating-a-personal-access-token");
			attr_dev(a, "target", "_blank");
			add_location(a, file, 71, 2, 1614);
			add_location(p2, file, 69, 0, 1566);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t1);
			insert_hydration_dev(target, t2, anchor);
			insert_hydration_dev(target, p0, anchor);
			append_hydration_dev(p0, t3);
			insert_hydration_dev(target, t4, anchor);
			insert_hydration_dev(target, h20, anchor);
			append_hydration_dev(h20, t5);
			insert_hydration_dev(target, t6, anchor);
			insert_hydration_dev(target, p1, anchor);
			append_hydration_dev(p1, t7);
			insert_hydration_dev(target, t8, anchor);
			insert_hydration_dev(target, h21, anchor);
			append_hydration_dev(h21, t9);
			insert_hydration_dev(target, t10, anchor);
			insert_hydration_dev(target, p2, anchor);
			append_hydration_dev(p2, t11);
			append_hydration_dev(p2, t12);
			append_hydration_dev(p2, a);
			append_hydration_dev(a, t13);
			insert_hydration_dev(target, t14, anchor);
			if_block.m(target, anchor);
			insert_hydration_dev(target, if_block_anchor, anchor);
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*config*/ 0 && title_value !== (title_value = config.i18n.rateLimitExceededTitle)) {
				document.title = title_value;
			}

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(if_block_anchor.parentNode, if_block_anchor);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p0);
			if (detaching) detach_dev(t4);
			if (detaching) detach_dev(h20);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(p1);
			if (detaching) detach_dev(t8);
			if (detaching) detach_dev(h21);
			if (detaching) detach_dev(t10);
			if (detaching) detach_dev(p2);
			if (detaching) detach_dev(t14);
			if_block.d(detaching);
			if (detaching) detach_dev(if_block_anchor);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Rate_limit_exceeded', slots, []);
	let token = "";
	let localStorageToken = false;

	const save = () => {
		if (typeof window !== "undefined" && "localStorage" in window) window.localStorage.setItem("personal-access-token", token);
		goto(config.path);
	};

	const remove = () => {
		$$invalidate(0, token = "");
		$$invalidate(1, localStorageToken = false);
		if (typeof window !== "undefined" && "localStorage" in window) window.localStorage.removeItem("personal-access-token");
	};

	onMount(() => {
		if (typeof window !== "undefined" && "localStorage" in window && localStorage.getItem("personal-access-token")) $$invalidate(1, localStorageToken = true);
	});

	const writable_props = [];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console.warn(`<Rate_limit_exceeded> was created with unknown prop '${key}'`);
	});

	function input_input_handler() {
		token = this.value;
		$$invalidate(0, token);
	}

	$$self.$capture_state = () => ({
		onMount,
		goto,
		config,
		token,
		localStorageToken,
		save,
		remove
	});

	$$self.$inject_state = $$props => {
		if ('token' in $$props) $$invalidate(0, token = $$props.token);
		if ('localStorageToken' in $$props) $$invalidate(1, localStorageToken = $$props.localStorageToken);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [token, localStorageToken, save, remove, input_input_handler];
}

class Rate_limit_exceeded extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance, create_fragment, safe_not_equal, {});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Rate_limit_exceeded",
			options,
			id: create_fragment.name
		});
	}
}

export { Rate_limit_exceeded as default };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmF0ZS1saW1pdC1leGNlZWRlZC40OTViMWE3Yi5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL3JvdXRlcy9yYXRlLWxpbWl0LWV4Y2VlZGVkLnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyI8c2NyaXB0PlxuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBnb3RvIH0gZnJvbSBcIkBzYXBwZXIvYXBwXCI7XG4gIGltcG9ydCBjb25maWcgZnJvbSBcIi4uL2RhdGEvY29uZmlnLmpzb25cIjtcblxuICBsZXQgdG9rZW4gPSBcIlwiO1xuICBsZXQgbG9jYWxTdG9yYWdlVG9rZW4gPSBmYWxzZTtcbiAgY29uc3Qgc2F2ZSA9ICgpID0+IHtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdylcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2Uuc2V0SXRlbShcInBlcnNvbmFsLWFjY2Vzcy10b2tlblwiLCB0b2tlbik7XG4gICAgZ290byhjb25maWcucGF0aCk7XG4gIH07XG4gIGNvbnN0IHJlbW92ZSA9ICgpID0+IHtcbiAgICB0b2tlbiA9IFwiXCI7XG4gICAgbG9jYWxTdG9yYWdlVG9rZW4gPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiBcImxvY2FsU3RvcmFnZVwiIGluIHdpbmRvdylcbiAgICAgIHdpbmRvdy5sb2NhbFN0b3JhZ2UucmVtb3ZlSXRlbShcInBlcnNvbmFsLWFjY2Vzcy10b2tlblwiKTtcbiAgfTtcbiAgb25Nb3VudCgoKSA9PiB7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuICAgICAgXCJsb2NhbFN0b3JhZ2VcIiBpbiB3aW5kb3cgJiZcbiAgICAgIGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwicGVyc29uYWwtYWNjZXNzLXRva2VuXCIpXG4gICAgKVxuICAgICAgbG9jYWxTdG9yYWdlVG9rZW4gPSB0cnVlO1xuICB9KTtcbjwvc2NyaXB0PlxuXG48c3R5bGU+XG4gIHAubGVhZCB7XG4gICAgZm9udC1zaXplOiAxMTAlO1xuICB9XG4gIGxhYmVsIHNwYW4ge1xuICAgIGRpc3BsYXk6IGJsb2NrO1xuICAgIGZvbnQtd2VpZ2h0OiBib2xkO1xuICAgIG1hcmdpbi1ib3R0b206IDAuNXJlbTtcbiAgfVxuICBpbnB1dCxcbiAgYnV0dG9uIHtcbiAgICBmb250OiBpbmhlcml0O1xuICAgIHBhZGRpbmc6IDAuNXJlbSAxcmVtO1xuICAgIGJvcmRlcjogMC4xcmVtIHNvbGlkIHJnYmEoMCwgMCwgMCwgMC4yNSk7XG4gICAgYm9yZGVyLXJhZGl1czogMC4ycmVtO1xuICB9XG4gIGlucHV0IHtcbiAgICB3aWR0aDogMTVyZW07XG4gICAgbWF4LXdpZHRoOiAxMDAlO1xuICB9XG4gIGJ1dHRvbiB7XG4gICAgYmFja2dyb3VuZC1jb2xvcjogIzAxYTNhNDtcbiAgICBjb2xvcjogI2ZmZjtcbiAgICBib3JkZXItY29sb3I6IHRyYW5zcGFyZW50O1xuICB9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG4gIDx0aXRsZT57Y29uZmlnLmkxOG4ucmF0ZUxpbWl0RXhjZWVkZWRUaXRsZX08L3RpdGxlPlxuPC9zdmVsdGU6aGVhZD5cblxuPGgxPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZFRpdGxlfTwvaDE+XG5cbjxwIGNsYXNzPVwibGVhZFwiPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZEludHJvfTwvcD5cblxuPGgyPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZFdoYXREb2VzRXJyb3JNZWFufTwvaDI+XG5cbjxwPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZEVycm9yTWVhbmluZ308L3A+XG5cbjxoMj57Y29uZmlnLmkxOG4ucmF0ZUxpbWl0RXhjZWVkZWRFcnJvckhvd0NhbkZpeH08L2gyPlxuXG48cD5cbiAge2NvbmZpZy5pMThuLnJhdGVMaW1pdEV4Y2VlZGVkRXJyb3JGaXh9XG4gIDxhXG4gICAgaHJlZj1cImh0dHBzOi8vZG9jcy5naXRodWIuY29tL2VuL2ZyZWUtcHJvLXRlYW1AbGF0ZXN0L2dpdGh1Yi9hdXRoZW50aWNhdGluZy10by1naXRodWIvY3JlYXRpbmctYS1wZXJzb25hbC1hY2Nlc3MtdG9rZW5cIlxuICAgIHRhcmdldD1cIl9ibGFua1wiPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZEdlbmVyYXRlUEFUfTwvYT5cbjwvcD5cblxueyNpZiBsb2NhbFN0b3JhZ2VUb2tlbn1cbiAgPHA+e2NvbmZpZy5pMThuLnJhdGVMaW1pdEV4Y2VlZGVkSGFzU2V0fTwvcD5cbiAgPGJ1dHRvbiBvbjpjbGljaz17cmVtb3ZlfT57Y29uZmlnLmkxOG4ucmF0ZUxpbWl0RXhjZWVkZWRSZW1vdmVUb2tlbn08L2J1dHRvbj5cbns6ZWxzZX1cbiAgPGZvcm0gb246c3VibWl0fHByZXZlbnREZWZhdWx0PXtzYXZlfT5cbiAgICA8bGFiZWw+XG4gICAgICA8c3Bhbj57Y29uZmlnLmkxOG4ucmF0ZUxpbWl0RXhjZWVkZWRHaXRIdWJQQVR9PC9zcGFuPlxuICAgICAgPGlucHV0XG4gICAgICAgIHR5cGU9XCJ0ZXh0XCJcbiAgICAgICAgYmluZDp2YWx1ZT17dG9rZW59XG4gICAgICAgIHBsYWNlaG9sZGVyPXtjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZENvcHlQYXN0ZVBBVH0gLz5cbiAgICA8L2xhYmVsPlxuICAgIDxidXR0b24gdHlwZT1cInN1Ym1pdFwiPntjb25maWcuaTE4bi5yYXRlTGltaXRFeGNlZWRlZFNhdmVUb2tlbn08L2J1dHRvbj5cbiAgPC9mb3JtPlxuey9pZn1cbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O2dCQWtGYSxNQUFNLENBQUMsSUFBSSxDQUFDLDBCQUEwQjs7Ozs7O2dCQU14QixNQUFNLENBQUMsSUFBSSxDQUFDLDBCQUEwQjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2tDQUY1QyxNQUFNLENBQUMsSUFBSSxDQUFDLDZCQUE2Qjs7Ozs7Ozs7Ozs7R0FONUQsb0JBU087R0FSTCxvQkFNUTtHQUxOLG9CQUFxRDs7O0dBQ3JELG9CQUc0RDtvQ0FEOUMsR0FBSzs7R0FHckIsb0JBQXVFOzs7Ozs7eURBUnpDLEdBQUk7Ozs7Ozs7d0RBS2xCLEdBQUs7cUNBQUwsR0FBSzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O2dCQVJuQixNQUFNLENBQUMsSUFBSSxDQUFDLHVCQUF1Qjs7OztnQkFDWixNQUFNLENBQUMsSUFBSSxDQUFDLDRCQUE0Qjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FEbkUsb0JBQTRDOzs7R0FDNUMsb0JBQTZFOzs7O3FEQUEzRCxHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFuQnJCLE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCOzs7O2dCQUV0QixNQUFNLENBQUMsSUFBSSxDQUFDLHNCQUFzQjs7OztnQkFFOUMsTUFBTSxDQUFDLElBQUksQ0FBQyxrQ0FBa0M7Ozs7Z0JBRS9DLE1BQU0sQ0FBQyxJQUFJLENBQUMsNkJBQTZCOzs7O2dCQUV4QyxNQUFNLENBQUMsSUFBSSxDQUFDLCtCQUErQjs7OztpQkFHN0MsTUFBTSxDQUFDLElBQUksQ0FBQyx5QkFBeUI7Ozs7aUJBR25CLE1BQU0sQ0FBQyxJQUFJLENBQUMsNEJBQTRCOzs7O2dDQWpCbkQsTUFBTSxDQUFDLElBQUksQ0FBQyxzQkFBc0I7Ozs0QkFvQnZDLEdBQWlCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQWpCdEIsb0JBQTZDOzs7R0FFN0Msb0JBQXdEOzs7R0FFeEQsb0JBQXlEOzs7R0FFekQsb0JBQWtEOzs7R0FFbEQsb0JBQXNEOzs7R0FFdEQsb0JBS0k7OztHQUhGLG9CQUVnRTs7Ozs7Ozs4REFqQnhELE1BQU0sQ0FBQyxJQUFJLENBQUMsc0JBQXNCOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7S0FuRHRDLEtBQUssR0FBRyxFQUFFO0tBQ1YsaUJBQWlCLEdBQUcsS0FBSzs7T0FDdkIsSUFBSTthQUNHLE1BQU0sS0FBSyxXQUFXLElBQUksY0FBYyxJQUFJLE1BQU0sRUFDM0QsTUFBTSxDQUFDLFlBQVksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLEVBQUUsS0FBSztFQUM1RCxJQUFJLENBQUMsTUFBTSxDQUFDLElBQUk7OztPQUVaLE1BQU07a0JBQ1YsS0FBSyxHQUFHLEVBQUU7a0JBQ1YsaUJBQWlCLEdBQUcsS0FBSzthQUNkLE1BQU0sS0FBSyxXQUFXLElBQUksY0FBYyxJQUFJLE1BQU0sRUFDM0QsTUFBTSxDQUFDLFlBQVksQ0FBQyxVQUFVLENBQUMsdUJBQXVCOzs7Q0FFMUQsT0FBTzthQUVJLE1BQU0sS0FBSyxXQUFXLElBQzdCLGNBQWMsSUFBSSxNQUFNLElBQ3hCLFlBQVksQ0FBQyxPQUFPLENBQUMsdUJBQXVCLG1CQUU1QyxpQkFBaUIsR0FBRyxJQUFJOzs7Ozs7Ozs7O0VBNkRWLEtBQUs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OzsifQ==
